{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-c335f8abfdbf9fc25d3a0f11e3a3ff8f89ccfd88",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ChitChainFactory.sol": "project/contracts/ChitChainFactory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@pythnetwork/entropy-sdk-solidity/=npm/@pythnetwork/entropy-sdk-solidity@2.0.0/",
        "project/:@pythnetwork/entropy-sdk-solidity/=npm/@pythnetwork/entropy-sdk-solidity@2.0.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@4.9.6/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/security/Pausable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/security/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@pythnetwork/entropy-sdk-solidity@2.0.0/EntropyEvents.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./EntropyStructs.sol\";\n\n// Deprecated -- these events are still emitted, but the lack of indexing\n// makes them hard to use.\ninterface EntropyEvents {\n    event Registered(EntropyStructs.ProviderInfo provider);\n\n    event Requested(EntropyStructs.Request request);\n    event RequestedWithCallback(\n        address indexed provider,\n        address indexed requestor,\n        uint64 indexed sequenceNumber,\n        bytes32 userRandomNumber,\n        EntropyStructs.Request request\n    );\n\n    event Revealed(\n        EntropyStructs.Request request,\n        bytes32 userRevelation,\n        bytes32 providerRevelation,\n        bytes32 blockHash,\n        bytes32 randomNumber\n    );\n    event RevealedWithCallback(\n        EntropyStructs.Request request,\n        bytes32 userRandomNumber,\n        bytes32 providerRevelation,\n        bytes32 randomNumber\n    );\n\n    event CallbackFailed(\n        address indexed provider,\n        address indexed requestor,\n        uint64 indexed sequenceNumber,\n        bytes32 userRandomNumber,\n        bytes32 providerRevelation,\n        bytes32 randomNumber,\n        bytes errorCode\n    );\n\n    event ProviderFeeUpdated(address provider, uint128 oldFee, uint128 newFee);\n\n    event ProviderDefaultGasLimitUpdated(\n        address indexed provider,\n        uint32 oldDefaultGasLimit,\n        uint32 newDefaultGasLimit\n    );\n\n    event ProviderUriUpdated(address provider, bytes oldUri, bytes newUri);\n\n    event ProviderFeeManagerUpdated(\n        address provider,\n        address oldFeeManager,\n        address newFeeManager\n    );\n    event ProviderMaxNumHashesAdvanced(\n        address provider,\n        uint32 oldMaxNumHashes,\n        uint32 newMaxNumHashes\n    );\n\n    event Withdrawal(\n        address provider,\n        address recipient,\n        uint128 withdrawnAmount\n    );\n}\n"
      },
      "npm/@pythnetwork/entropy-sdk-solidity@2.0.0/EntropyEventsV2.sol": {
        "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./EntropyStructs.sol\";\n\n/**\n * @title EntropyEventsV2\n * @notice Interface defining events for the Entropy V2 system, which handles random number generation\n * and provider management on Ethereum.\n * @dev This interface is used to emit events that track the lifecycle of random number requests,\n * provider registrations, and system configurations.\n */\ninterface EntropyEventsV2 {\n    /**\n     * @notice Emitted when a new provider registers with the Entropy system\n     * @param provider The address of the registered provider\n     * @param extraArgs A field for extra data for forward compatibility.\n     */\n    event Registered(address indexed provider, bytes extraArgs);\n\n    /**\n     * @notice Emitted when a user requests a random number from a provider\n     * @param provider The address of the provider handling the request\n     * @param caller The address of the user requesting the random number\n     * @param sequenceNumber A unique identifier for this request\n     * @param userContribution The user's contribution to the random number\n     * @param gasLimit The gas limit for the callback.\n     * @param extraArgs A field for extra data for forward compatibility.\n     */\n    event Requested(\n        address indexed provider,\n        address indexed caller,\n        uint64 indexed sequenceNumber,\n        bytes32 userContribution,\n        uint32 gasLimit,\n        bytes extraArgs\n    );\n\n    /**\n     * @notice Emitted when a provider reveals the generated random number\n     * @param provider The address of the provider that generated the random number\n     * @param caller The address of the user who requested the random number (and who receives a callback)\n     * @param sequenceNumber The unique identifier of the request\n     * @param randomNumber The generated random number\n     * @param userContribution The user's contribution to the random number\n     * @param providerContribution The provider's contribution to the random number\n     * @param callbackFailed Whether the callback to the caller failed\n     * @param callbackReturnValue Return value from the callback. If the callback failed, this field contains\n     * the error code and any additional returned data. Note that \"\" often indicates an out-of-gas error.\n     * If the callback returns more than 256 bytes, only the first 256 bytes of the callback return value are included.\n     * @param callbackGasUsed How much gas the callback used.\n     * @param extraArgs A field for extra data for forward compatibility.\n     */\n    event Revealed(\n        address indexed provider,\n        address indexed caller,\n        uint64 indexed sequenceNumber,\n        bytes32 randomNumber,\n        bytes32 userContribution,\n        bytes32 providerContribution,\n        bool callbackFailed,\n        bytes callbackReturnValue,\n        uint32 callbackGasUsed,\n        bytes extraArgs\n    );\n\n    /**\n     * @notice Emitted when a provider updates their fee\n     * @param provider The address of the provider updating their fee\n     * @param oldFee The previous fee amount\n     * @param newFee The new fee amount\n     * @param extraArgs A field for extra data for forward compatibility.\n     */\n    event ProviderFeeUpdated(\n        address indexed provider,\n        uint128 oldFee,\n        uint128 newFee,\n        bytes extraArgs\n    );\n\n    /**\n     * @notice Emitted when a provider updates their default gas limit\n     * @param provider The address of the provider updating their gas limit\n     * @param oldDefaultGasLimit The previous default gas limit\n     * @param newDefaultGasLimit The new default gas limit\n     * @param extraArgs A field for extra data for forward compatibility.\n     */\n    event ProviderDefaultGasLimitUpdated(\n        address indexed provider,\n        uint32 oldDefaultGasLimit,\n        uint32 newDefaultGasLimit,\n        bytes extraArgs\n    );\n\n    /**\n     * @notice Emitted when a provider updates their URI\n     * @param provider The address of the provider updating their URI\n     * @param oldUri The previous URI\n     * @param newUri The new URI\n     * @param extraArgs A field for extra data for forward compatibility.\n     */\n    event ProviderUriUpdated(\n        address indexed provider,\n        bytes oldUri,\n        bytes newUri,\n        bytes extraArgs\n    );\n\n    /**\n     * @notice Emitted when a provider updates their fee manager address\n     * @param provider The address of the provider updating their fee manager\n     * @param oldFeeManager The previous fee manager address\n     * @param newFeeManager The new fee manager address\n     * @param extraArgs A field for extra data for forward compatibility.\n     */\n    event ProviderFeeManagerUpdated(\n        address indexed provider,\n        address oldFeeManager,\n        address newFeeManager,\n        bytes extraArgs\n    );\n\n    /**\n     * @notice Emitted when a provider updates their maximum number of hashes that can be advanced\n     * @param provider The address of the provider updating their max hashes\n     * @param oldMaxNumHashes The previous maximum number of hashes\n     * @param newMaxNumHashes The new maximum number of hashes\n     * @param extraArgs A field for extra data for forward compatibility.\n     */\n    event ProviderMaxNumHashesAdvanced(\n        address indexed provider,\n        uint32 oldMaxNumHashes,\n        uint32 newMaxNumHashes,\n        bytes extraArgs\n    );\n\n    /**\n     * @notice Emitted when a provider withdraws their accumulated fees\n     * @param provider The address of the provider withdrawing fees\n     * @param recipient The address receiving the withdrawn fees\n     * @param withdrawnAmount The amount of fees withdrawn\n     * @param extraArgs A field for extra data for forward compatibility.\n     */\n    event Withdrawal(\n        address indexed provider,\n        address indexed recipient,\n        uint128 withdrawnAmount,\n        bytes extraArgs\n    );\n}\n"
      },
      "npm/@pythnetwork/entropy-sdk-solidity@2.0.0/EntropyStructs.sol": {
        "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\n// This contract holds old versions of the Entropy structs that are no longer used for contract storage.\n// However, they are still used in EntropyEvents to maintain the public interface of prior versions of\n// the Entropy contract.\n//\n// See EntropyStructsV2 for the struct definitions currently in use.\ncontract EntropyStructs {\n    struct ProviderInfo {\n        uint128 feeInWei;\n        uint128 accruedFeesInWei;\n        // The commitment that the provider posted to the blockchain, and the sequence number\n        // where they committed to this. This value is not advanced after the provider commits,\n        // and instead is stored to help providers track where they are in the hash chain.\n        bytes32 originalCommitment;\n        uint64 originalCommitmentSequenceNumber;\n        // Metadata for the current commitment. Providers may optionally use this field to help\n        // manage rotations (i.e., to pick the sequence number from the correct hash chain).\n        bytes commitmentMetadata;\n        // Optional URI where clients can retrieve revelations for the provider.\n        // Client SDKs can use this field to automatically determine how to retrieve random values for each provider.\n        // TODO: specify the API that must be implemented at this URI\n        bytes uri;\n        // The first sequence number that is *not* included in the current commitment (i.e., an exclusive end index).\n        // The contract maintains the invariant that sequenceNumber <= endSequenceNumber.\n        // If sequenceNumber == endSequenceNumber, the provider must rotate their commitment to add additional random values.\n        uint64 endSequenceNumber;\n        // The sequence number that will be assigned to the next inbound user request.\n        uint64 sequenceNumber;\n        // The current commitment represents an index/value in the provider's hash chain.\n        // These values are used to verify requests for future sequence numbers. Note that\n        // currentCommitmentSequenceNumber < sequenceNumber.\n        //\n        // The currentCommitment advances forward through the provider's hash chain as values\n        // are revealed on-chain.\n        bytes32 currentCommitment;\n        uint64 currentCommitmentSequenceNumber;\n        // An address that is authorized to set / withdraw fees on behalf of this provider.\n        address feeManager;\n        // Maximum number of hashes to record in a request. This should be set according to the maximum gas limit\n        // the provider supports for callbacks.\n        uint32 maxNumHashes;\n    }\n\n    struct Request {\n        // Storage slot 1 //\n        address provider;\n        uint64 sequenceNumber;\n        // The number of hashes required to verify the provider revelation.\n        uint32 numHashes;\n        // Storage slot 2 //\n        // The commitment is keccak256(userCommitment, providerCommitment). Storing the hash instead of both saves 20k gas by\n        // eliminating 1 store.\n        bytes32 commitment;\n        // Storage slot 3 //\n        // The number of the block where this request was created.\n        // Note that we're using a uint64 such that we have an additional space for an address and other fields in\n        // this storage slot. Although block.number returns a uint256, 64 bits should be plenty to index all of the\n        // blocks ever generated.\n        uint64 blockNumber;\n        // The address that requested this random number.\n        address requester;\n        // If true, incorporate the blockhash of blockNumber into the generated random value.\n        bool useBlockhash;\n        // True if this is a request that expects a callback.\n        bool isRequestWithCallback;\n    }\n}\n"
      },
      "npm/@pythnetwork/entropy-sdk-solidity@2.0.0/EntropyStructsV2.sol": {
        "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\ncontract EntropyStructsV2 {\n    struct ProviderInfo {\n        uint128 feeInWei;\n        uint128 accruedFeesInWei;\n        // The commitment that the provider posted to the blockchain, and the sequence number\n        // where they committed to this. This value is not advanced after the provider commits,\n        // and instead is stored to help providers track where they are in the hash chain.\n        bytes32 originalCommitment;\n        uint64 originalCommitmentSequenceNumber;\n        // Metadata for the current commitment. Providers may optionally use this field to help\n        // manage rotations (i.e., to pick the sequence number from the correct hash chain).\n        bytes commitmentMetadata;\n        // Optional URI where clients can retrieve revelations for the provider.\n        // Client SDKs can use this field to automatically determine how to retrieve random values for each provider.\n        // TODO: specify the API that must be implemented at this URI\n        bytes uri;\n        // The first sequence number that is *not* included in the current commitment (i.e., an exclusive end index).\n        // The contract maintains the invariant that sequenceNumber <= endSequenceNumber.\n        // If sequenceNumber == endSequenceNumber, the provider must rotate their commitment to add additional random values.\n        uint64 endSequenceNumber;\n        // The sequence number that will be assigned to the next inbound user request.\n        uint64 sequenceNumber;\n        // The current commitment represents an index/value in the provider's hash chain.\n        // These values are used to verify requests for future sequence numbers. Note that\n        // currentCommitmentSequenceNumber < sequenceNumber.\n        //\n        // The currentCommitment advances forward through the provider's hash chain as values\n        // are revealed on-chain.\n        bytes32 currentCommitment;\n        uint64 currentCommitmentSequenceNumber;\n        // An address that is authorized to set / withdraw fees on behalf of this provider.\n        address feeManager;\n        // Maximum number of hashes to record in a request. This should be set according to the maximum gas limit\n        // the provider supports for callbacks.\n        uint32 maxNumHashes;\n        // Default gas limit to use for callbacks.\n        uint32 defaultGasLimit;\n    }\n\n    struct Request {\n        // Storage slot 1 //\n        address provider;\n        uint64 sequenceNumber;\n        // The number of hashes required to verify the provider revelation.\n        uint32 numHashes;\n        // Storage slot 2 //\n        // The commitment is keccak256(userCommitment, providerCommitment). Storing the hash instead of both saves 20k gas by\n        // eliminating 1 store.\n        bytes32 commitment;\n        // Storage slot 3 //\n        // The number of the block where this request was created.\n        // Note that we're using a uint64 such that we have an additional space for an address and other fields in\n        // this storage slot. Although block.number returns a uint256, 64 bits should be plenty to index all of the\n        // blocks ever generated.\n        uint64 blockNumber;\n        // The address that requested this random number.\n        address requester;\n        // If true, incorporate the blockhash of blockNumber into the generated random value.\n        bool useBlockhash;\n        // Status flag for requests with callbacks. See EntropyConstants for the possible values of this flag.\n        uint8 callbackStatus;\n        // The gasLimit in units of 10k gas. (i.e., 2 = 20k gas). We're using units of 10k in order to fit this\n        // field into the remaining 2 bytes of this storage slot. The dynamic range here is 10k - 655M, which should\n        // cover all real-world use cases.\n        uint16 gasLimit10k;\n    }\n}\n"
      },
      "npm/@pythnetwork/entropy-sdk-solidity@2.0.0/IEntropy.sol": {
        "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.0;\n\nimport \"./EntropyEvents.sol\";\nimport \"./EntropyEventsV2.sol\";\nimport \"./EntropyStructsV2.sol\";\nimport \"./IEntropyV2.sol\";\n\ninterface IEntropy is EntropyEvents, EntropyEventsV2, IEntropyV2 {\n    // Register msg.sender as a randomness provider. The arguments are the provider's configuration parameters\n    // and initial commitment. Re-registering the same provider rotates the provider's commitment (and updates\n    // the feeInWei).\n    //\n    // chainLength is the number of values in the hash chain *including* the commitment, that is, chainLength >= 1.\n    function register(\n        uint128 feeInWei,\n        bytes32 commitment,\n        bytes calldata commitmentMetadata,\n        uint64 chainLength,\n        bytes calldata uri\n    ) external;\n\n    // Withdraw a portion of the accumulated fees for the provider msg.sender.\n    // Calling this function will transfer `amount` wei to the caller (provided that they have accrued a sufficient\n    // balance of fees in the contract).\n    function withdraw(uint128 amount) external;\n\n    // Withdraw a portion of the accumulated fees for provider. The msg.sender must be the fee manager for this provider.\n    // Calling this function will transfer `amount` wei to the caller (provided that they have accrued a sufficient\n    // balance of fees in the contract).\n    function withdrawAsFeeManager(address provider, uint128 amount) external;\n\n    // As a user, request a random number from `provider`. Prior to calling this method, the user should\n    // generate a random number x and keep it secret. The user should then compute hash(x) and pass that\n    // as the userCommitment argument. (You may call the constructUserCommitment method to compute the hash.)\n    //\n    // This method returns a sequence number. The user should pass this sequence number to\n    // their chosen provider (the exact method for doing so will depend on the provider) to retrieve the provider's\n    // number. The user should then call fulfillRequest to construct the final random number.\n    //\n    // This method will revert unless the caller provides a sufficient fee (at least getFee(provider)) as msg.value.\n    // Note that excess value is *not* refunded to the caller.\n    function request(\n        address provider,\n        bytes32 userCommitment,\n        bool useBlockHash\n    ) external payable returns (uint64 assignedSequenceNumber);\n\n    // Request a random number. The method expects the provider address and a secret random number\n    // in the arguments. It returns a sequence number.\n    //\n    // The address calling this function should be a contract that inherits from the IEntropyConsumer interface.\n    // The `entropyCallback` method on that interface will receive a callback with the generated random number.\n    // `entropyCallback` will be run with the provider's default gas limit (see `getProviderInfo(provider).defaultGasLimit`).\n    // If your callback needs additional gas, please use `requestWithCallbackAndGasLimit`.\n    //\n    // This method will revert unless the caller provides a sufficient fee (at least `getFee(provider)`) as msg.value.\n    // Note that excess value is *not* refunded to the caller.\n    function requestWithCallback(\n        address provider,\n        bytes32 userRandomNumber\n    ) external payable returns (uint64 assignedSequenceNumber);\n\n    // Fulfill a request for a random number. This method validates the provided userRandomness and provider's proof\n    // against the corresponding commitments in the in-flight request. If both values are validated, this function returns\n    // the corresponding random number.\n    //\n    // Note that this function can only be called once per in-flight request. Calling this function deletes the stored\n    // request information (so that the contract doesn't use a linear amount of storage in the number of requests).\n    // If you need to use the returned random number more than once, you are responsible for storing it.\n    function reveal(\n        address provider,\n        uint64 sequenceNumber,\n        bytes32 userRevelation,\n        bytes32 providerRevelation\n    ) external returns (bytes32 randomNumber);\n\n    // Fulfill a request for a random number. This method validates the provided userRandomness\n    // and provider's revelation against the corresponding commitment in the in-flight request. If both values are validated\n    // and the requestor address is a contract address, this function calls the requester's entropyCallback method with the\n    // sequence number, provider address and the random number as arguments. Else if the requestor is an EOA, it won't call it.\n    //\n    // Note that this function can only be called once per in-flight request. Calling this function deletes the stored\n    // request information (so that the contract doesn't use a linear amount of storage in the number of requests).\n    // If you need to use the returned random number more than once, you are responsible for storing it.\n    //\n    // Anyone can call this method to fulfill a request, but the callback will only be made to the original requester.\n    function revealWithCallback(\n        address provider,\n        uint64 sequenceNumber,\n        bytes32 userRandomNumber,\n        bytes32 providerRevelation\n    ) external;\n\n    function getProviderInfo(\n        address provider\n    ) external view returns (EntropyStructs.ProviderInfo memory info);\n\n    function getRequest(\n        address provider,\n        uint64 sequenceNumber\n    ) external view returns (EntropyStructs.Request memory req);\n\n    // Get the fee charged by provider for a request with the default gasLimit (`request` or `requestWithCallback`).\n    // If you are calling any of the `requestV2` methods, please use `getFeeV2`.\n    function getFee(address provider) external view returns (uint128 feeAmount);\n\n    function getAccruedPythFees()\n        external\n        view\n        returns (uint128 accruedPythFeesInWei);\n\n    function setProviderFee(uint128 newFeeInWei) external;\n\n    function setProviderFeeAsFeeManager(\n        address provider,\n        uint128 newFeeInWei\n    ) external;\n\n    function setProviderUri(bytes calldata newUri) external;\n\n    // Set manager as the fee manager for the provider msg.sender.\n    // After calling this function, manager will be able to set the provider's fees and withdraw them.\n    // Only one address can be the fee manager for a provider at a time -- calling this function again with a new value\n    // will override the previous value. Call this function with the all-zero address to disable the fee manager role.\n    function setFeeManager(address manager) external;\n\n    // Set the maximum number of hashes to record in a request. This should be set according to the maximum gas limit\n    // the provider supports for callbacks.\n    function setMaxNumHashes(uint32 maxNumHashes) external;\n\n    // Set the default gas limit for a request. If 0, no\n    function setDefaultGasLimit(uint32 gasLimit) external;\n\n    // Advance the provider commitment and increase the sequence number.\n    // This is used to reduce the `numHashes` required for future requests which leads to reduced gas usage.\n    function advanceProviderCommitment(\n        address provider,\n        uint64 advancedSequenceNumber,\n        bytes32 providerRevelation\n    ) external;\n\n    function constructUserCommitment(\n        bytes32 userRandomness\n    ) external pure returns (bytes32 userCommitment);\n\n    function combineRandomValues(\n        bytes32 userRandomness,\n        bytes32 providerRandomness,\n        bytes32 blockHash\n    ) external pure returns (bytes32 combinedRandomness);\n}\n"
      },
      "npm/@pythnetwork/entropy-sdk-solidity@2.0.0/IEntropyConsumer.sol": {
        "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.0;\n\nabstract contract IEntropyConsumer {\n    // This method is called by Entropy to provide the random number to the consumer.\n    // It asserts that the msg.sender is the Entropy contract. It is not meant to be\n    // override by the consumer.\n    function _entropyCallback(\n        uint64 sequence,\n        address provider,\n        bytes32 randomNumber\n    ) external {\n        address entropy = getEntropy();\n        require(entropy != address(0), \"Entropy address not set\");\n        require(msg.sender == entropy, \"Only Entropy can call this function\");\n\n        entropyCallback(sequence, provider, randomNumber);\n    }\n\n    // getEntropy returns Entropy contract address. The method is being used to check that the\n    // callback is indeed from Entropy contract. The consumer is expected to implement this method.\n    // Entropy address can be found here - https://docs.pyth.network/entropy/contract-addresses\n    function getEntropy() internal view virtual returns (address);\n\n    // This method is expected to be implemented by the consumer to handle the random number.\n    // It will be called by _entropyCallback after _entropyCallback ensures that the call is\n    // indeed from Entropy contract.\n    function entropyCallback(\n        uint64 sequence,\n        address provider,\n        bytes32 randomNumber\n    ) internal virtual;\n}\n"
      },
      "npm/@pythnetwork/entropy-sdk-solidity@2.0.0/IEntropyV2.sol": {
        "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.0;\n\nimport \"./EntropyEvents.sol\";\nimport \"./EntropyEventsV2.sol\";\nimport \"./EntropyStructsV2.sol\";\n\ninterface IEntropyV2 is EntropyEventsV2 {\n    /// @notice Request a random number using the default provider with default gas limit\n    /// @return assignedSequenceNumber A unique identifier for this request\n    /// @dev The address calling this function should be a contract that inherits from the IEntropyConsumer interface.\n    /// The `entropyCallback` method on that interface will receive a callback with the returned sequence number and\n    /// the generated random number.\n    ///\n    /// `entropyCallback` will be run with the `gasLimit` provided to this function.\n    /// The `gasLimit` will be rounded up to a multiple of 10k (e.g., 19000 -> 20000), and furthermore is lower bounded\n    /// by the provider's configured default limit.\n    ///\n    /// This method will revert unless the caller provides a sufficient fee (at least `getFeeV2()`) as msg.value.\n    /// Note that the fee can change over time. Callers of this method should explicitly compute `getFeeV2()`\n    /// prior to each invocation (as opposed to hardcoding a value). Further note that excess value is *not* refunded to the caller.\n    ///\n    /// Note that this method uses an in-contract PRNG to generate the user's contribution to the random number.\n    /// This approach modifies the security guarantees such that a dishonest validator and provider can\n    /// collude to manipulate the result (as opposed to a malicious user and provider). That is, the user\n    /// now trusts the validator honestly draw a random number. If you wish to avoid this trust assumption,\n    /// call a variant of `requestV2` that accepts a `userRandomNumber` parameter.\n    function requestV2()\n        external\n        payable\n        returns (uint64 assignedSequenceNumber);\n\n    /// @notice Request a random number using the default provider with specified gas limit\n    /// @param gasLimit The gas limit for the callback function.\n    /// @return assignedSequenceNumber A unique identifier for this request\n    /// @dev The address calling this function should be a contract that inherits from the IEntropyConsumer interface.\n    /// The `entropyCallback` method on that interface will receive a callback with the returned sequence number and\n    /// the generated random number.\n    ///\n    /// `entropyCallback` will be run with the `gasLimit` provided to this function.\n    /// The `gasLimit` will be rounded up to a multiple of 10k (e.g., 19000 -> 20000), and furthermore is lower bounded\n    /// by the provider's configured default limit.\n    ///\n    /// This method will revert unless the caller provides a sufficient fee (at least `getFeeV2(gasLimit)`) as msg.value.\n    /// Note that the fee can change over time. Callers of this method should explicitly compute `getFeeV2(gasLimit)`\n    /// prior to each invocation (as opposed to hardcoding a value). Further note that excess value is *not* refunded to the caller.\n    ///\n    /// Note that this method uses an in-contract PRNG to generate the user's contribution to the random number.\n    /// This approach modifies the security guarantees such that a dishonest validator and provider can\n    /// collude to manipulate the result (as opposed to a malicious user and provider). That is, the user\n    /// now trusts the validator honestly draw a random number. If you wish to avoid this trust assumption,\n    /// call a variant of `requestV2` that accepts a `userRandomNumber` parameter.\n    function requestV2(\n        uint32 gasLimit\n    ) external payable returns (uint64 assignedSequenceNumber);\n\n    /// @notice Request a random number from a specific provider with specified gas limit\n    /// @param provider The address of the provider to request from\n    /// @param gasLimit The gas limit for the callback function\n    /// @return assignedSequenceNumber A unique identifier for this request\n    /// @dev The address calling this function should be a contract that inherits from the IEntropyConsumer interface.\n    /// The `entropyCallback` method on that interface will receive a callback with the returned sequence number and\n    /// the generated random number.\n    ///\n    /// `entropyCallback` will be run with the `gasLimit` provided to this function.\n    /// The `gasLimit` will be rounded up to a multiple of 10k (e.g., 19000 -> 20000), and furthermore is lower bounded\n    /// by the provider's configured default limit.\n    ///\n    /// This method will revert unless the caller provides a sufficient fee (at least `getFeeV2(provider, gasLimit)`) as msg.value.\n    /// Note that provider fees can change over time. Callers of this method should explicitly compute `getFeeV2(provider, gasLimit)`\n    /// prior to each invocation (as opposed to hardcoding a value). Further note that excess value is *not* refunded to the caller.\n    ///\n    /// Note that this method uses an in-contract PRNG to generate the user's contribution to the random number.\n    /// This approach modifies the security guarantees such that a dishonest validator and provider can\n    /// collude to manipulate the result (as opposed to a malicious user and provider). That is, the user\n    /// now trusts the validator honestly draw a random number. If you wish to avoid this trust assumption,\n    /// call a variant of `requestV2` that accepts a `userRandomNumber` parameter.\n    function requestV2(\n        address provider,\n        uint32 gasLimit\n    ) external payable returns (uint64 assignedSequenceNumber);\n\n    /// @notice Request a random number from a specific provider with a user-provided random number and gas limit\n    /// @param provider The address of the provider to request from\n    /// @param userRandomNumber A random number provided by the user for additional entropy\n    /// @param gasLimit The gas limit for the callback function. Pass 0 to get a sane default value -- see note below.\n    /// @return assignedSequenceNumber A unique identifier for this request\n    /// @dev The address calling this function should be a contract that inherits from the IEntropyConsumer interface.\n    /// The `entropyCallback` method on that interface will receive a callback with the returned sequence number and\n    /// the generated random number.\n    ///\n    /// `entropyCallback` will be run with the `gasLimit` provided to this function.\n    /// The `gasLimit` will be rounded up to a multiple of 10k (e.g., 19000 -> 20000), and furthermore is lower bounded\n    /// by the provider's configured default limit.\n    ///\n    /// This method will revert unless the caller provides a sufficient fee (at least `getFeeV2(provider, gasLimit)`) as msg.value.\n    /// Note that provider fees can change over time. Callers of this method should explicitly compute `getFeeV2(provider, gasLimit)`\n    /// prior to each invocation (as opposed to hardcoding a value). Further note that excess value is *not* refunded to the caller.\n    function requestV2(\n        address provider,\n        bytes32 userRandomNumber,\n        uint32 gasLimit\n    ) external payable returns (uint64 assignedSequenceNumber);\n\n    /// @notice Get information about a specific entropy provider\n    /// @param provider The address of the provider to query\n    /// @return info The provider information including configuration, fees, and operational status\n    /// @dev This method returns detailed information about a provider's configuration and capabilities.\n    /// The returned ProviderInfo struct contains information such as the provider's fee structure and gas limits.\n    function getProviderInfoV2(\n        address provider\n    ) external view returns (EntropyStructsV2.ProviderInfo memory info);\n\n    /// @notice Get the address of the default entropy provider\n    /// @return provider The address of the default provider\n    /// @dev This method returns the address of the provider that will be used when no specific provider is specified\n    /// in the requestV2 calls. The default provider can be used to get the base fee and gas limit information.\n    function getDefaultProvider() external view returns (address provider);\n\n    /// @notice Get information about a specific request\n    /// @param provider The address of the provider that handled the request\n    /// @param sequenceNumber The unique identifier of the request\n    /// @return req The request information including status, random number, and other metadata\n    /// @dev This method allows querying the state of a previously made request. The returned Request struct\n    /// contains information about whether the request was fulfilled, the generated random number (if available),\n    /// and other metadata about the request.\n    function getRequestV2(\n        address provider,\n        uint64 sequenceNumber\n    ) external view returns (EntropyStructsV2.Request memory req);\n\n    /// @notice Get the fee charged by the default provider for the default gas limit\n    /// @return feeAmount The fee amount in wei\n    /// @dev This method returns the base fee required to make a request using the default provider with\n    /// the default gas limit. This fee should be passed as msg.value when calling requestV2().\n    /// The fee can change over time, so this method should be called before each request.\n    function getFeeV2() external view returns (uint128 feeAmount);\n\n    /// @notice Get the fee charged by the default provider for a specific gas limit\n    /// @param gasLimit The gas limit for the callback function\n    /// @return feeAmount The fee amount in wei\n    /// @dev This method returns the fee required to make a request using the default provider with\n    /// the specified gas limit. This fee should be passed as msg.value when calling requestV2(gasLimit).\n    /// The fee can change over time, so this method should be called before each request.\n    function getFeeV2(\n        uint32 gasLimit\n    ) external view returns (uint128 feeAmount);\n\n    /// @notice Get the fee charged by a specific provider for a request with a given gas limit\n    /// @param provider The address of the provider to query\n    /// @param gasLimit The gas limit for the callback function\n    /// @return feeAmount The fee amount in wei\n    /// @dev This method returns the fee required to make a request using the specified provider with\n    /// the given gas limit. This fee should be passed as msg.value when calling requestV2(provider, gasLimit)\n    /// or requestV2(provider, userRandomNumber, gasLimit). The fee can change over time, so this method\n    /// should be called before each request.\n    function getFeeV2(\n        address provider,\n        uint32 gasLimit\n    ) external view returns (uint128 feeAmount);\n}\n"
      },
      "project/contracts/ChitChainFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./ChitChainManager.sol\";\n\n/**\n * @title ChitChainFactory\n * @dev Factory contract to deploy and manage multiple ChitChain instances\n */\ncontract ChitChainFactory is Ownable {\n    address public immutable entropyAddress;\n    address[] public deployedSchemes;\n    mapping(address => bool) public isValidScheme;\n\n    event SchemeDeployed(address indexed scheme, address indexed deployer);\n\n    constructor(address _entropy) {\n        entropyAddress = _entropy;\n    }\n\n    function deployChitChain() external returns (address) {\n        ChitChainManager newScheme = new ChitChainManager(entropyAddress);\n        newScheme.transferOwnership(msg.sender);\n\n        deployedSchemes.push(address(newScheme));\n        isValidScheme[address(newScheme)] = true;\n\n        emit SchemeDeployed(address(newScheme), msg.sender);\n        return address(newScheme);\n    }\n\n    function getDeployedSchemes() external view returns (address[] memory) {\n        return deployedSchemes;\n    }\n}\n"
      },
      "project/contracts/ChitChainManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@pythnetwork/entropy-sdk-solidity/IEntropy.sol\";\nimport \"@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./libraries/Structs.sol\";\nimport \"./libraries/Events.sol\";\nimport \"./libraries/Errors.sol\";\n\n/**\n * @title ChitChainManager\n * @dev Main contract managing all chit schemes with Pyth Entropy integration\n */\ncontract ChitChainManager is IEntropyConsumer, ReentrancyGuard, Ownable, Pausable {\n    using Structs for Structs.ChitScheme;\n    using Structs for Structs.CycleData;\n    using Structs for Structs.UserProfile;\n\n    IEntropy private entropy;\n\n    // Constants\n    uint256 public constant INVESTMENT_PERIOD = 5 days;\n    uint256 public constant BIDDING_PERIOD = 5 days;\n    uint256 public constant ORGANIZER_FEE_PERCENT = 5;\n    uint256 public constant MIN_BID_PERCENT = 75; // Minimum 75% of pool\n    uint256 public constant CYCLE_LENGTH = 30 days;\n\n    // State variables\n    uint256 public nextSchemeId;\n    mapping(uint256 => Structs.ChitScheme) public schemes;\n    mapping(uint256 => mapping(uint256 => Structs.CycleData)) public cycleData; // schemeId => cycle => data\n    mapping(address => Structs.UserProfile) public users;\n    mapping(uint64 => uint256) public entropyToScheme; // entropy sequence => scheme ID\n    mapping(uint64 => uint256) public entropyCycle; // entropy sequence => cycle number\n\n    constructor(address _entropy) {\n        entropy = IEntropy(_entropy);\n        nextSchemeId = 1;\n    }\n\n    // User Registration\n    function registerUser() external {\n        if (users[msg.sender].isRegistered) revert(\"Already registered\");\n        users[msg.sender].isRegistered = true;\n        emit Events.UserRegistered(msg.sender);\n    }\n\n    // Scheme Creation\n    function createScheme(\n        string memory _schemeName,\n        uint256 _monthlyAmount,\n        uint256 _totalCycles,\n        uint256 _maxMembers\n    ) external whenNotPaused returns (uint256) {\n        if (!users[msg.sender].isRegistered) revert(\"Must be registered\");\n        if (_monthlyAmount == 0) revert Errors.InvalidAmount();\n        if (_totalCycles == 0 || _totalCycles > 60) revert(\"Invalid cycle count\");\n        if (_maxMembers < 2 || _maxMembers > 100) revert(\"Invalid member count\");\n\n        uint256 schemeId = nextSchemeId++;\n\n        Structs.ChitScheme storage scheme = schemes[schemeId];\n        scheme.schemeId = schemeId;\n        scheme.organizer = msg.sender;\n        scheme.schemeName = _schemeName;\n        scheme.monthlyAmount = _monthlyAmount;\n        scheme.totalCycles = _totalCycles;\n        scheme.currentCycle = 0;\n        scheme.maxMembers = _maxMembers;\n        scheme.isActive = true;\n        scheme.createdAt = block.timestamp;\n\n        scheme.members.push(msg.sender);\n        users[msg.sender].participatingSchemes.push(schemeId);\n\n        emit Events.SchemeCreated(schemeId, msg.sender, _schemeName);\n        return schemeId;\n    }\n\n    // Join Scheme\n    function joinScheme(uint256 _schemeId) external whenNotPaused {\n        if (!users[msg.sender].isRegistered) revert(\"Must be registered\");\n        Structs.ChitScheme storage scheme = schemes[_schemeId];\n        if (!scheme.isActive) revert Errors.SchemeNotActive();\n        if (scheme.members.length >= scheme.maxMembers) revert Errors.MaxMembersReached();\n\n        for (uint256 i = 0; i < scheme.members.length; i++) {\n            if (scheme.members[i] == msg.sender) revert Errors.AlreadyMember();\n        }\n\n        scheme.members.push(msg.sender);\n        users[msg.sender].participatingSchemes.push(_schemeId);\n\n        emit Events.UserJoinedScheme(_schemeId, msg.sender);\n    }\n\n    // Start new cycle\n    function startNewCycle(uint256 _schemeId) external whenNotPaused {\n        Structs.ChitScheme storage scheme = schemes[_schemeId];\n        if (!scheme.isActive) revert Errors.SchemeNotActive();\n        if (scheme.members.length < 2) revert(\"Need at least 2 members\");\n\n        if (scheme.currentCycle == 0) {\n            scheme.currentCycle = 1;\n            scheme.lastCycleStart = block.timestamp;\n        } else {\n            if (block.timestamp < scheme.lastCycleStart + CYCLE_LENGTH) revert(\"Current cycle not completed\");\n            if (!cycleData[_schemeId][scheme.currentCycle].isComplete) revert(\"Previous cycle not completed\");\n\n            scheme.currentCycle++;\n            scheme.lastCycleStart = block.timestamp;\n\n            if (scheme.currentCycle > scheme.totalCycles) {\n                scheme.isActive = false;\n                emit Events.SchemeCompleted(_schemeId);\n                return;\n            }\n        }\n    }\n\n    // Contribute to current cycle\n    function contribute(uint256 _schemeId) external payable nonReentrant whenNotPaused {\n        Structs.ChitScheme storage scheme = schemes[_schemeId];\n        if (!scheme.isActive) revert Errors.SchemeNotActive();\n\n        bool isMember = false;\n        for (uint256 i = 0; i < scheme.members.length; i++) {\n            if (scheme.members[i] == msg.sender) {\n                isMember = true;\n                break;\n            }\n        }\n        if (!isMember) revert Errors.OnlyMember();\n\n        if (msg.value != scheme.monthlyAmount) revert Errors.InvalidAmount();\n        if (scheme.currentCycle == 0) revert(\"No active cycle\");\n\n        uint256 cycleStart = scheme.lastCycleStart;\n        if (block.timestamp > cycleStart + INVESTMENT_PERIOD) revert Errors.ContributionPeriodEnded();\n\n        Structs.CycleData storage cycle = cycleData[_schemeId][scheme.currentCycle];\n        if (cycle.hasContributed[msg.sender]) revert Errors.AlreadyContributed();\n\n        cycle.hasContributed[msg.sender] = true;\n        cycle.contributions[msg.sender] = msg.value;\n        cycle.contributors.push(msg.sender);\n        cycle.totalPool += msg.value;\n        cycle.contributionsReceived++;\n        users[msg.sender].totalContributions += msg.value;\n\n        emit Events.ContributionMade(_schemeId, scheme.currentCycle, msg.sender, msg.value);\n    }\n    \n    // Place a bid\n    function placeBid(uint256 _schemeId, uint256 _bidAmount) external whenNotPaused {\n        Structs.ChitScheme storage scheme = schemes[_schemeId];\n        if (!scheme.isActive) revert Errors.SchemeNotActive();\n        if (scheme.currentCycle == 0) revert(\"No active cycle\");\n\n        Structs.CycleData storage cycle = cycleData[_schemeId][scheme.currentCycle];\n        if (!cycle.hasContributed[msg.sender]) revert Errors.NotEligibleToBid();\n        if (cycle.hasBid[msg.sender]) revert Errors.AlreadyBid();\n\n        uint256 cycleStart = scheme.lastCycleStart;\n        if (block.timestamp <= cycleStart + INVESTMENT_PERIOD || block.timestamp > cycleStart + INVESTMENT_PERIOD + BIDDING_PERIOD) {\n            revert Errors.BiddingPeriodEnded();\n        }\n\n        uint256 minBid = (cycle.totalPool * MIN_BID_PERCENT) / 100;\n        if (_bidAmount < minBid || _bidAmount > cycle.totalPool) revert Errors.BidTooLow();\n\n        cycle.hasBid[msg.sender] = true;\n        cycle.bids[msg.sender] = _bidAmount;\n        cycle.bidders.push(msg.sender);\n\n        emit Events.BidPlaced(_schemeId, scheme.currentCycle, msg.sender, _bidAmount);\n    }\n\n    // Select winner\n    function selectWinner(uint256 _schemeId) external payable nonReentrant whenNotPaused {\n        Structs.ChitScheme storage scheme = schemes[_schemeId];\n        if (!scheme.isActive) revert Errors.SchemeNotActive();\n        if (scheme.currentCycle == 0) revert(\"No active cycle\");\n\n        Structs.CycleData storage cycle = cycleData[_schemeId][scheme.currentCycle];\n        if (cycle.bidders.length == 0) revert Errors.NoBidsReceived();\n        if (cycle.winner != address(0)) revert Errors.WinnerAlreadySelected();\n\n        uint256 cycleStart = scheme.lastCycleStart;\n        if(block.timestamp <= cycleStart + INVESTMENT_PERIOD + BIDDING_PERIOD) revert(\"Bidding period not ended\");\n\n        uint128 fee = entropy.getFee(entropy.getDefaultProvider());\n        if (msg.value < fee) revert Errors.InsufficientBalance();\n\n        bytes32 seed = keccak256(abi.encodePacked(block.timestamp, _schemeId, scheme.currentCycle));\n        uint64 sequenceNumber = entropy.requestWithCallback{ value: fee }(entropy.getDefaultProvider(), seed);\n\n        cycle.entropySequenceNumber = sequenceNumber;\n        entropyToScheme[sequenceNumber] = _schemeId;\n        entropyCycle[sequenceNumber] = scheme.currentCycle;\n\n        if (msg.value > fee) {\n            payable(msg.sender).transfer(msg.value - fee);\n        }\n\n        emit Events.RandomnessRequested(_schemeId, scheme.currentCycle, sequenceNumber);\n    }\n    \n    // Entropy callback\n    function entropyCallback(uint64 sequenceNumber, address, bytes32 randomNumber) internal override {\n        uint256 schemeId = entropyToScheme[sequenceNumber];\n        uint256 cycleNum = entropyCycle[sequenceNumber];\n\n        Structs.CycleData storage cycle = cycleData[schemeId][cycleNum];\n\n        if(cycle.bidders.length == 0) revert Errors.NoBidsReceived();\n        if(cycle.winner != address(0)) revert Errors.WinnerAlreadySelected();\n\n        uint256 winnerIndex = uint256(randomNumber) % cycle.bidders.length;\n        address winner = cycle.bidders[winnerIndex];\n        uint256 winningBid = cycle.bids[winner];\n\n        cycle.winner = winner;\n        cycle.winningBid = winningBid;\n\n        users[winner].schemesWon++;\n        users[winner].totalEarnings += winningBid;\n\n        emit Events.WinnerSelected(schemeId, cycleNum, winner, winningBid);\n        _distributeFunds(schemeId, cycleNum);\n    }\n    \n    // Internal function for fund distribution\n    function _distributeFunds(uint256 _schemeId, uint256 _cycleNum) internal {\n        Structs.ChitScheme storage scheme = schemes[_schemeId];\n        Structs.CycleData storage cycle = cycleData[_schemeId][_cycleNum];\n\n        uint256 totalPool = cycle.totalPool;\n        uint256 organizerFee = (totalPool * ORGANIZER_FEE_PERCENT) / 100;\n        uint256 winnerAmount = cycle.winningBid;\n        uint256 dividendPool = totalPool - organizerFee - winnerAmount;\n\n        payable(cycle.winner).transfer(winnerAmount);\n        payable(scheme.organizer).transfer(organizerFee);\n\n        if (dividendPool > 0 && cycle.contributors.length > 1) {\n            uint256 dividendPerMember = dividendPool / (cycle.contributors.length - 1);\n            for (uint256 i = 0; i < cycle.contributors.length; i++) {\n                address member = cycle.contributors[i];\n                if (member != cycle.winner) {\n                    payable(member).transfer(dividendPerMember);\n                    users[member].totalEarnings += dividendPerMember;\n                    emit Events.DividendDistributed(_schemeId, _cycleNum, member, dividendPerMember);\n                }\n            }\n        }\n        cycle.isComplete = true;\n    }\n\n    // View functions\n    function getScheme(uint256 _schemeId) external view returns (Structs.ChitScheme memory) {\n        return schemes[_schemeId];\n    }\n\n    function getSchemeMembers(uint256 _schemeId) external view returns (address[] memory) {\n        return schemes[_schemeId].members;\n    }\n\n    function getCycleInfo(uint256 _schemeId, uint256 _cycle) external view returns (uint256 totalPool, uint256 contributionsReceived, address winner, uint256 winningBid, bool isComplete) {\n        Structs.CycleData storage cycle = cycleData[_schemeId][_cycle];\n        return (cycle.totalPool, cycle.contributionsReceived, cycle.winner, cycle.winningBid, cycle.isComplete);\n    }\n    \n    function getUserProfile(address _user) external view returns (Structs.UserProfile memory) {\n        return users[_user];\n    }\n    \n    function getCurrentCyclePeriod(uint256 _schemeId) external view returns (string memory) {\n        Structs.ChitScheme storage scheme = schemes[_schemeId];\n        if (!scheme.isActive || scheme.currentCycle == 0) return \"INACTIVE\";\n\n        uint256 timeElapsed = block.timestamp - scheme.lastCycleStart;\n        if (timeElapsed <= INVESTMENT_PERIOD) return \"CONTRIBUTION\";\n        if (timeElapsed <= INVESTMENT_PERIOD + BIDDING_PERIOD) return \"BIDDING\";\n        return \"SELECTION\";\n    }\n\n    function getRandomnessFee() external view returns (uint128) {\n        return entropy.getFee(entropy.getDefaultProvider());\n    }\n\n    // Admin functions\n    function pause() external onlyOwner { _pause(); }\n    function unpause() external onlyOwner { _unpause(); }\n    function emergencyWithdraw() external onlyOwner {\n        payable(owner()).transfer(address(this).balance);\n    }\n    \n    receive() external payable {}\n    function getEntropy() internal view virtual override returns (address) {\n        return address(entropy);\n    }\n}\n"
      },
      "project/contracts/libraries/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title Errors\n * @dev Defines all custom errors for the ChitChainManager contract.\n */\nlibrary Errors {\n    error OnlyOrganizer();\n    error OnlyMember();\n    error InvalidAmount();\n    error InvalidPeriod();\n    error SchemeNotActive();\n    error AlreadyMember();\n    error MaxMembersReached();\n    error ContributionPeriodEnded();\n    error BiddingPeriodEnded();\n    error BidTooLow();\n    error AlreadyContributed();\n    error AlreadyBid();\n    error NotEligibleToBid();\n    error NoBidsReceived();\n    error WinnerAlreadySelected();\n    error InsufficientBalance();\n}\n"
      },
      "project/contracts/libraries/Events.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title Events\n * @dev Defines all events emitted by the ChitChainManager contract.\n */\nlibrary Events {\n    event UserRegistered(address indexed user);\n    event SchemeCreated(uint256 indexed schemeId, address indexed organizer, string schemeName);\n    event UserJoinedScheme(uint256 indexed schemeId, address indexed user);\n    event ContributionMade(\n        uint256 indexed schemeId,\n        uint256 indexed cycle,\n        address indexed contributor,\n        uint256 amount\n    );\n    event BidPlaced(uint256 indexed schemeId, uint256 indexed cycle, address indexed bidder, uint256 amount);\n    event WinnerSelected(uint256 indexed schemeId, uint256 indexed cycle, address indexed winner, uint256 amount);\n    event DividendDistributed(uint256 indexed schemeId, uint256 indexed cycle, address indexed member, uint256 amount);\n    event SchemeCompleted(uint256 indexed schemeId);\n    event RandomnessRequested(uint256 indexed schemeId, uint256 indexed cycle, uint64 sequenceNumber);\n}\n"
      },
      "project/contracts/libraries/Structs.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/**\n * @title Structs\n * @dev Defines the core data structures for the ChitChain ecosystem.\n */\nlibrary Structs {\n    struct ChitScheme {\n        uint256 schemeId;\n        address organizer;\n        string schemeName;\n        uint256 monthlyAmount;\n        uint256 totalCycles;\n        uint256 currentCycle;\n        uint256 maxMembers;\n        address[] members;\n        bool isActive;\n        uint256 createdAt;\n        uint256 lastCycleStart;\n    }\n\n    struct CycleData {\n        uint256 totalPool;\n        uint256 contributionsReceived;\n        address[] contributors;\n        address[] bidders;\n        mapping(address => uint256) contributions;\n        mapping(address => uint256) bids;\n        mapping(address => bool) hasContributed;\n        mapping(address => bool) hasBid;\n        address winner;\n        uint256 winningBid;\n        bool isComplete;\n        uint64 entropySequenceNumber;\n    }\n\n    struct UserProfile {\n        bool isRegistered;\n        uint256[] participatingSchemes;\n        uint256 totalEarnings;\n        uint256 totalContributions;\n        uint256 schemesWon;\n    }\n}\n"
      }
    }
  }
}